#include "IOStream.h"
#include <vector>
#include <cinttypes>
#include <json.hpp>
#include <glm/vec3.hpp>
#include <glm/vec4.hpp>

using namespace IOReader;
using json = nlohmann::json;

constexpr FileAccess ReadBinary = FileAccess(FileAccess::Read & FileAccess::Binary);
constexpr FileAccess WriteBinary = FileAccess(FileAccess::Write & FileAccess::Binary);

const std::string outputFolder = "./output/";
const std::string sceneFile = "scene.json";

struct Mesh
{
    std::string filename;
    int indexCount;
    std::string meshName;
    int vertexCount;
    int wireCount;
    int indexTypeSize;

    std::vector<glm::vec3> faces;
    std::vector<glm::vec3> vertices;
    std::vector<glm::vec3> uvs;
    std::vector<glm::vec3> normals;
    std::vector<glm::vec4> color;
};

class MViewParser
{
public:
    MViewParser( const std::string& filename )
        : m_binary_reader( filename )
    {}

    void GetPackedFiles()
    {
        while( !m_binary_reader.EndOfFile() )
        {
            std::string filename = m_binary_reader.ReadString();
            std::string mimetype = m_binary_reader.ReadString();
            if( filename.empty() )
            {
                break;
            }
            // Skip trash
            // Zero byte
            m_binary_reader.Get<uint32_t>();
            // Get file size
            int filesize = m_binary_reader.Get<uint32_t>();
            m_binary_reader.Get<uint32_t>();
            // Create a new file buffer
            {
                std::string path = outputFolder + filename;
                m_files.push_back( path );
                BinaryWriter<WriteBinary> bw( path );
                for( int i = 0; i < filesize; ++i )
                {
                    char filebyte = m_binary_reader.Get<char>();
                    bw.Set<char>( filebyte, sizeof(char) );
                }
            }
        }
    }

    void ParseScene()
    {
        BinaryReader<FileAccess::Read> scene( outputFolder + sceneFile );
        std::string incoming_json = scene.ReadString();
        json j = json::parse( incoming_json );
        std::cout << j.dump(4) << std::endl;
        if( !j["meshes"].is_null() && j["meshes"].is_array() )
        {
            for( size_t i = 0; i < j["meshes"].size(); ++i )
            {
                auto mesh_json = j["meshes"][i];
                Mesh m;
                m.filename = mesh_json[ "file" ];
                m.vertexCount = mesh_json[ "vertexCount" ];
                m.indexCount = mesh_json[ "indexCount" ];
                m.meshName = mesh_json[ "name" ];
                m.filename = mesh_json[ "file" ];
                m.wireCount = mesh_json[ "wireCount" ];
                m.indexTypeSize = mesh_json["indexTypeSize"];
                ParseMesh( m );
                m_meshes.push_back( std::move( m ) );
            }
        }
    }

    void ParseMesh( Mesh& m )
    {
        BinaryReader<ReadBinary> mesh_stream( outputFolder + m.filename );
        // Read faces
        for( int index = 0; index < m.indexCount / 3; ++index ) // some fix for face parsing
        {
            uint16_t a = mesh_stream.Get<uint16_t>() + 1;
            uint16_t b = mesh_stream.Get<uint16_t>() + 1;
            uint16_t c = mesh_stream.Get<uint16_t>() + 1;
            m.faces.push_back( glm::vec3( a, b, c) );
        }
        int offset = ( m.indexCount + m.wireCount ) * m.indexTypeSize;
        mesh_stream.Skip( offset );
        for( int index = 0; index < m.vertexCount; ++index )
        {
            // Vertices
            float x = mesh_stream.Get<float>();
            float y = mesh_stream.Get<float>();
            float z = mesh_stream.Get<float>();
            std::cout << x << ", " << y << ", " << z <<std::endl;
            m.vertices.push_back( glm::vec3( x, y, z ) ); // x -z y wtf?
            // Texture uvs
            float u = mesh_stream.Get<float>();
            float v = mesh_stream.Get<float>();
            m.uvs.push_back( glm::vec3( u, v, 0.0f ) );
            // Normals
            float nx = mesh_stream.Get<float>();
            float ny = mesh_stream.Get<float>();
            m.normals.push_back( glm::vec3( nx, ny, 1.0f ) );
            // Color
            int8_t r = mesh_stream.Get<int8_t>();
            int8_t g = mesh_stream.Get<int8_t>();
            int8_t b = mesh_stream.Get<int8_t>();
            int8_t a = mesh_stream.Get<int8_t>();
            m.color.push_back( glm::vec4( r, g, b, a) );
        }
    }

    void GenerateWavefront()
    {
        for( const auto& mesh: m_meshes )
        {
            std::string filename = outputFolder + mesh.filename;
            DefaultStream<FileAccess::Write> mtl_writer( filename + std::string(".mtl") );
            DefaultStream<FileAccess::Write> wf_writer( filename + std::string(".obj") );
            // Write faces
            wf_writer.Set( "# Generated by MView parser\n" );
            // External mtl
            wf_writer.Set( std::string( "mtllib " ).append( mesh.filename ).append( ".mtl" ) );
            for( size_t index = 0; index < mesh.faces.size(); ++index )
            {
                std::string face_line = "f ";
                auto face = mesh.faces.at(index);
                std::string x = std::to_string( (int) face.x ); // first vertex
                std::string y = std::to_string( (int) face.y ); // second vertex
                std::string z = std::to_string( (int) face.z ); // third vertex

                face_line += x + "/" + x + "/" + x + " ";
                face_line += y + "/" + y + "/" + y + " ";
                face_line += z + "/" + z + "/" + z + '\n';
                wf_writer.Set<std::string>( face_line );
            }
            // Write vertices
            for( size_t index = 0; index < mesh.vertices.size(); ++index )
            {
                std::string vertex_line = "v ";
                auto vertex = mesh.vertices.at(index);
                vertex_line += std::to_string( vertex.x ) + " ";
                vertex_line += std::to_string( vertex.y ) + " ";
                vertex_line += std::to_string( vertex.z ) + '\n';
                wf_writer.Set<std::string>( vertex_line );
            }
        }
    }

private:
    BinaryReader<ReadBinary> m_binary_reader;
    std::vector<std::string> m_files;
    std::vector<Mesh> m_meshes;
};

